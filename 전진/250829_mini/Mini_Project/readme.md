인터페이스 실습- 음식 주문 시스템을 활용

메뉴를 주문하고 주문한 메뉴를 확인하는 기능
메인 함수에서는 무한 반복문을 통해 메뉴 주문, 주문 메뉴 확인을 여러번 선택할 수 있고 시스템 종료로 프로그램을 종료할 수 있다. 


메뉴 주문 과정 전체는 OrderSystem 클래스라는 메인 컨트롤러 클래스에서 진행한다.
주문이 시작되면 한식, 중식, 일식, 양식을 선택하고, 종류별로 해당하는 식당 클래스가 호출된다.


추상클래스 AbstractRestaurant를 상속받은 한식당, 중식당, 일식당, 양식당 클래스를 작성하였다. 
기존 음식 주문 시스템에서는 Orderable 인터페이스를 사용하였으나, 같은 기능을 수행하는 중복함수가 발생하여 추상 클래스로 변경하였다.
식당 종류 별로 하나의 클래스를 가지고, 각각의 Restaurant 클래스들이 식당 종류 전체를 담당한다. 
Restaurant 클래스들은 Restaurant_Info 객체들로 이루어진 Restaurant_List와 주문관리 클래스 OrderManager를 필드로 가지고, 
레스토랑을 선택하는 chooseRestaurant 메소드, 메뉴를 선택하는 chooseMenu 메소드,  선택한 메뉴를 주문관리 클래스를 통해 주문하는 order 메소드를 가진다. 

Restaurant_info 객체는 식당명을 저장하는 Restaurant_Name 변수와 메뉴를 저장하는 객체 Menu_Item으로 이루어진 Menu_List로 구성된다. 
하나의 Restaurant_info 객체가 식당 하나의 정보를 저장한다. 

Menu_Item 객체는 메뉴 이름과 가격 정보를 저장한다.
하나의 Menu_Item객체가 메뉴 하나의 정보를 저장한다. 

주문은 OrderManager 클래스에서 담당한다. 
OrderManager는 주문 정보를 저장하는 OrderItem 객체로 이루어진 OrderList를 필드로 저장한다. 
OrderManager는 새로 생성되지 않고, OrderSystem 클래스에서 하나만 생성되어 이곳저곳으로 전달된다. 
OrderManager 클래스는 OrderList에 주문을 추가하는 addOrder함수와 모든 주문을 출력하는 printAllorder 함수를 가진다. 
addOrder함수는 각 식당에서 주문을 받았을때 호출되고, printAllorder함수는 시스템 메뉴에서 주문한 메뉴를 확인하려고 할 때 호출된다. 

아직 보완하거나, 추가할 점.
OrderStatus 열거형을 통해 조리 상태(조리 중, 배달 중, 배달 완료 등등)을 확인할 수 있게 하려고 했으나, 
각각의 식당 클래스가 하나의 식당을 객체로 가지지 않아 이를 식당클래스에서 호출하는게 적절한지 아직 정하지 못했고,
현재 주문 목록을 orderManager에서 하나의 OrderList로 관리하고 있는데 접근 권한 같은 걸 설정해주지 않으면, 
식당에서 자기 메뉴가 아닌 다른 식당의 메뉴 조리상태를 수정할 수 있게 될 거 같아 이 문제를 해결해야 함.

OrderManager 클래스에 싱글톤 패턴을 적용하지 않은 이유.
싱글톤은 주로 전역에서 접근해야하는 리소스인데 OrderManager 클래스가 전역에 다 필요하지 않고, 
OrderSystem이라는 메인 컨트롤러 클래스가 있어서 여기서 생성하고 전달하는게 좀 더 적합하다.
싱글톤 패턴은 게임/시뮬레이션/주문 관리 같은 애플리케이션 레벨 로직에는 덜 적합하다고 한다.

재밌었던 점, 어려웠던 점, 느낀 점
프로그램을 설계하고 구조화하면서 코드로 작성하는 과정 자체가 즐거웠다. 내가 머릿속에서 그리는 것들을 코드로 옮기는 게 재밌었던거 같다. 
어려웠던 점은 아직 특정 정보를 객체로 저장할지, 변수로 저장할지 견적을 잘못 잡아서 설계할 땐 map으로 설계했지만 구현할 땐 객체로 구현하는 경우가 있었다. 
그밖에도 인터페이스로 구현했지만 추상 클래스로 변경한 경우도 있었다. 
