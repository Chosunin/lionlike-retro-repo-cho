자바기본 훈련평가 오답노트
==============

틀린 문제: 4, 5, 7, 8, 9, 15, 16, 18, 19

내가 고른 답 : ✔
정답 : ✅

## 4. 다음 중 **인터페이스**에 대한 설명으로 *틀린 것*은 무엇인가요?

### ⓛ 인터페이스는 `implements` 키워드를 사용해 구현한다.
##### ➡️ 선언은 `interface` 구현은 `implements` 로 한다.
### ② 인터페이스에 선언된 메서드는 기본적으로 `public abstract`이다.
##### ➡️ 모든 구현 클래스에서 접근 가능해야하며(`publice`), 실제 구현이 없고, 반드시 구현 클래스에서 재정의 해야하기(`abstract`) 때문이다.
### ③ 인터페이스는 다중 구현이 가능하다.
##### ➡️ Java는 다중 상속을 허용하지 않지만 인터페이스는 가능하다. 이것이 가능한 이유는 인터페이스는 구현이 없는 추상 메서드 집합이기 때문이다.
```java
interface Flyable { void methodA(); }
interface Singable { void methodB(); }

class MyBird implements Flyable, Singable {
    public void methodA() { System.out.println("fly"); }
    public void methodB() { System.out.println("sing"); }
}
```
### ④ 인터페이스에는 생성자를 선언할 수 있다.✅
##### ➡️ 인터페이스 자첼는 인스턴스를 만들 수 없기에 생성자라는 개념이 필요하지 않다.
##### 인터페이스의 역할은 필드 초기화나 구현 로직이 아니고 **이 기능을 반드시 구현해야한다** 라는 메서드의 집합 역할만 한다.
### ⑤ 인터페이스에는 상수만 선언할 수 있다. ✔
>이게 상수밖에 선언 못한다는 의미는 아니고, 
>상수만 선언해도 괜찮다 이런 의미랍니다. 
>혹시 헷갈리실까봐서 알려드려요^^
-----------
## 5. 다음 코드의 실행 결과로 옳은 것은 무엇인가요?
```java
public class Test {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("예외 발생");
        } finally {
            System.out.println("마무리 작업");
        }
    }
}
```
##### ➡️10 / 0 → ArithmeticException 발생

catch (ArithmeticException e) 블록 실행 → "예외 발생" 출력

finally 블록은 예외 여부와 관계없이 항상 실행 → "마무리 작업" 출력



### ⓛ 예외 발생  ✔
### ② 마무리 작업
### ③ 예외 발생 \n 마무리 작업 ✅
### ④ 컴파일 오류
### ⑤ 아무것도 출력되지 않는다

-----------
## 7. 다음 코드의 실행 결과는 무엇인가요?
```java
String str1 = "java";
String str2 = "java";
String str3 = new String("java");

System.out.println(str1 == str2);
System.out.println(str1 == str3);
```
##### ➡️ A obj = new B();

변수 타입은 A, 그러나 실제 생성된 객체는 B.

System.out.println(obj);

내부적으로 obj.toString()을 호출.

메서드 오버라이딩 규칙에 따라, 참조 변수 타입이 아니라 실제 객체 타입(B) 의 toString()이 실행.

즉, B 클래스의 toString() → "B" 반환.

이것을 자식 객체를 부모타입으로 참조하는 것 (업캐스팅, Upcasting) 이라고 한다.



### ⓛ A ✔
### ② B ✅
### ③ 컴파일 오류 
### ④ 실행 오류
### ⑤ null

-----------------
## 8. 다음 코드의 실행 결과로 옳은 것은 무엇인가요?
```java
class A {
    public String toString() { return "A"; }
}

class B extends A {
    public String toString() { return "B"; }
}

public class Test {
    public static void main(String[] args) {
        A obj = new B();
        System.out.println(obj);
    }
}
```
##### ➡️ 1. str1과 str2

"java"는 문자열 리터럴 상수 풀(String Constant Pool) 에 저장.

동일한 리터럴 "java"를 재사용하면, 같은 주소를 참조.

따라서 str1 == str2 → **true**

##### ➡️ 2. str1과 str3

new String("java")는 힙(Heap) 영역에 새로운 객체를 강제로 생성.

따라서 str3는 "java"라는 같은 내용을 가지고 있어도 다른 주소를 가진다.

따라서 str1 == str3 → **false**



### ⓛ true true ✔
### ② true false ✅
### ③ false true
### ④ false false
### ⑤ 컴파일 오류

-----------------
## 9. 다음 중 `this` 키워드의 사용으로 *틀린 것*은 무엇인가요?

### ⓛ 인스턴스 변수를 참조할 때 사용한다.
##### ➡️ 지역 변수와 인스턴스 변수 이름이 겹칠 때 주로 사용.
### ② 현재 객체를 가리킨다.
##### ➡️ 메서드 안에서 this는 그 메서드를 호출한 객체 자신을 가리킴.
### ③ 클래스 변수(static)를 참조할 때 사용한다.✅
##### ➡️ static 변수/메서드는 객체가 *아니라*  클래스에 속함. 
그래서 this로 접근 불가, 클래스명.변수 형태로 접근해야 함.
### ④ 생성자에서 다른 생성자를 호출할 때 사용된다. ✔
##### ➡️ 같은 클래스의 다른 생성자를 호출할 수 있음.
### ⑤ 메서드 내에서 현재 객체를 반환할 때 사용된다.
##### ➡️ return this; 형태로 자기 자신을 반환 가능.

-----------
## 15. 다음 중 추상 클래스와 인터페이스의 차이점에 대한 설명으로 *옳은 것*은 무엇인가요?
##### ➡️ 지난 회고시간에 추상 클래스와 인터페이스의 차이점과 공통점을 내가 발표했는데 틀려서 너무 화가난다. 
|          | 추상 클래스                                        | 인터페이스                     |
|----------|-----------------------------------------------|---------------------------|
| 정의       | 객체를 생성하는 것을 제한된 클래스                           | 추상메서드의 집합                 |
| 구현하는법    | 단일상속을 통한 구현                                   | 다중상속을 통한 구현               |
| 선언 /구현   | `abstract class` , `extends`                  | `interface` , `implements` |
| 생성자 소유가부 | 가능                                            | 불가능                       |
| 필드       | 인스턴스 변수, 상수 가능                                | `public static final`만 가능 |
| 관계 표현    | is-a, kind of                                 | can-do                    |
| 공통점 1    | 객체를 직접 `new`할 수 없음. 상속이나 구현을 해야함.             
| 공통점 2    | 부모 객체가 자식 객체를 참조가능(상속의 한 방법이기 때문에)            
| 공통점 3    | 반드시 메서드 생성은 자식클래스에서 해야함(본 클래스에서 만들 수 없게 만들었음) |
| 사용 상황    | 단일상속만이 필요하고 위계가 확실하여 공통속성을 사용해야함.             | 다중상속을 해야할 만큼 속성이 다양함.     |

### ⓛ 추상 클래스는 메서드를 구현할 수 없지만, 인터페이스는 구현할 수 있다.
### ② 인터페이스는 `extends` 키워드를 사용하지만, 추상 클래스는 `implements`를 사용한다.
### ③ 추상 클래스는 필드와 생성자를 가질 수 있지만, 인터페이스는 가질 수 없다. ✅
### ④ 인터페이스는 단일 상속만 가능하지만, 추상 클래스는 다중 상속이 가능하다.
### ⑤ 추상 클래스와 인터페이스 모두 객체를 생성할 수 있다. ✔


-----------
## 16. 다음 코드의 실행 결과는 무엇인가요?
```java
public class Test {
    public static void main(String[] args) {
        try {
            System.out.println("try");
            throw new RuntimeException();
        } catch (Exception e) {
            System.out.println("catch");
        } finally {
            System.out.println("finally");
        }
    }
}
```
##### ➡️ try 블록 진입 → "try" 출력

##### ➡️ throw new RuntimeException(); 실행 → 예외 발생

##### ➡️ catch (Exception e) 블록 → RuntimeException은 Exception의 자식 클래스이므로 잡힘 → "catch" 출력

##### ➡️ finally 블록은 예외 발생 여부와 상관없이 항상 실행 → "finally" 출력



### ⓛ try catch 
### ② try catch finally ✅
### ③ try finally✔
### ④ catch finally
### ⑤ 실행 오류

-----------------
## 18. 다음 중 메서드 오버라이딩에 대한 조건으로 *틀린 것*은 무엇인가요?
### ⓛ 메서드 이름이 같아야 한다..
### ② 매개변수의 개수와 타입이 같아야 한다.
### ③ 리턴 타입이 같거나 하위 타입이어야 한다.
### ④ 접근 제어자는 부모 클래스보다 더 좁게 제한할 수 있다.✅
##### ➡️ 오버라이딩 시 접근 제어자는 같거나 더 넓어야 함
### ⑤ 상속 관계에서만 오버라이딩이 가능하다. ✔
### - 메서드 오버라이딩의 조건
##### 1. 상속 관계여야 한다
##### 2. 반드시 부모 클래스(또는 인터페이스)로부터 상속받은 메서드를 재정의해야 함.
##### 3.  메서드 이름이 같아야 한다
##### 4.  매개변수(파라미터)의 개수와 타입이 같아야 한다
##### 5. 리턴 타입은 같거나 하위 타입이어야 한다
##### 6.  접근 제어자는 부모 메서드와 같거나 더 넓어야 한다
##### 7. 부모가 protected라면 자식은 protected 또는 public 가능하지만, private은 불가.
##### 8. 예외(Exception) 선언 규칙
##### 9.  부모 메서드가 던지는 예외보다 같거나 더 좁은 범위의 예외만 선언 가능.



-----------------
## 19. 다음 코드의 실행 결과는 무엇인가요?
```java
class A {
    A() { System.out.println("A 생성자"); }
}

class B extends A {
    B() { System.out.println("B 생성자"); }
}

public class Test {
    public static void main(String[] args) {
        B b = new B();
    }
}
```
##### ➡️ new B() 호출 시,

가장 먼저 부모 클래스(A)의 생성자가 호출.

그 후 자식 클래스(B)의 생성자가 실행.

##### ➡️ 따라서 출력 순서:

"A 생성자"

"B 생성자"





### ⓛ A 생성자✔
### ② B 생성자 
### ③ A 생성자 B 생성자✅
### ④ 컴파일 오류
### ⑤ 실행 오류
