## 250820 회고내용

### Q1. 오늘 수업에서 몰랐던 점 정리.
A1. 
로또기계 실습시간에서 향상된 for문을 사용하여 해당 List<Ball> balls 안에 있던 ball을 삭제하려고 했으나 ConcurrentModificationException 오류가 발생했다.  
발생했던 오류와 해결방법을 알아보았다.
# ConcurrentModificationException에 대해서

## 왜 발생했나?
향상된 for문(`for (E e : list)`)은 내부적으로 `Iterator`를 사용한다. **순회 중에 같은 리스트를 구조적으로 수정**(add/remove/clear)하면 반복자가 컬렉션의 변경을 감지해 `ConcurrentModificationException`(CME)을 던진다.  
**해결:** `Iterator.remove()` 사용, 스냅샷 순회, `removeIf(...)`, `ListIterator`로 삽입/치환, 동시성 컬렉션 사용.

---

## 1) 문제 상황 예시
```java
List<String> list = new ArrayList<>(List.of("a","b","c"));
for (String s : list) {
  if (s.equals("b")) {
    list.remove(s);  // ❌ 다음 next()/hasNext() 시점에 CME
  }
}
```

로또 실습에서 `List<Ball> balls`를 향상된 for로 돌며 특정 `ball`을 삭제하려다 동일한 예외가 발생.

---

## 2) 왜 발생하나? — 향상된 for문은 Iterator 기반
컴파일러는 향상된 for를 대략 아래와 같이 전개한다(개념적 코드).

```java
for (java.util.Iterator<String> it = list.iterator(); it.hasNext(); ) {
    String s = it.next();
    if (s.equals("b")) {
        list.remove(s); // ← 반복자 외 경로로 컬렉션을 수정
        // 다음 it.hasNext()/it.next()에서 modCount 불일치 감지 → CME
    }
}
```

- 컬렉션은 내부적으로 **modCount(구조 변경 횟수)** 를 갖고, 반복자는 **expectedModCount** 를 저장.
- 순회 중 `add/remove/clear` 등으로 구조가 바뀌면 두 값이 어긋나 **fail-fast**로 예외 발생.

---

## 3) 왜 예외를 던지게 했나? (fail-fast의 의도)
- **요소 건너뜀/중복 방문 방지**: 배열 당김/재배치로 커서와 실제 데이터가 틀어질 수 있음.
- **구조 무결성 보호**: 해시 재배치(맵 등) 중 잘못된 포인터 접근 방지.
- **은폐된 버그 조기 노출**: 가끔만 재현되는 Heisenbug를 초기 단계에서 차단.
- **멀티스레드 경쟁 조건 방지**: 일관성 없는 스냅샷 읽기 방지.

---

## 4) 안전한 해결 패턴 모음

### 4-1) 삭제만 필요 — `Iterator.remove()` (권장)
```java
Iterator<String> it = list.iterator();
while (it.hasNext()) {
  if (it.next().startsWith("x")) {
    it.remove();                 // ✅ 안전
  }
}
```

### 4-2) 삽입/치환 필요 — `ListIterator` 사용
```java
ListIterator<String> it = list.listIterator(); // 또는 시작 인덱스 지정
while (it.hasNext()) {
  String s = it.next();
  if (s.equals("old")) it.set("new");   // 교체
  if (s.equals("mark")) it.add("after"); // 커서 위치에 삽입
}
```

### 4-3) 조건부 일괄 제거 — `removeIf(...)`
```java
list.removeIf(s -> s.equals("b")); // ✅ 외부에서 같은 리스트를 동시에 순회하지 않는 전제
```

### 4-4) 스냅샷 순회(복사본에서 돌기)
```java
for (String s : new ArrayList<>(list)) {  // 스냅샷
  if (s.equals("b")) list.remove(s);      // ✅ 원본 수정 가능 (복사 비용 O(n))
}
```

### 4-5) 역방향 인덱스 삭제 (리스트 전용)
```java
for (int i = list.size() - 1; i >= 0; i--) {
  if (조건) list.remove(i); // 뒤에서 앞으로 제거
}
```

---

## 5) Map에서도 비슷하게 발생 — 안전한 패턴
### 문제
```java
for (var e : map.entrySet()) {
  if (조건) map.remove(e.getKey()); // ❌ CME
}
```

### 해결
```java
Iterator<Map.Entry<K,V>> it = map.entrySet().iterator();
while (it.hasNext()) {
  if (조건) it.remove();  // ✅ 안전
}
```

혹은
```java
map.entrySet().removeIf(e -> 조건); // 외부 동시 수정 없다는 전제
```

---

## 6) 멀티스레드라면
- **읽기 많고 쓰기 드묾**: `CopyOnWriteArrayList` (반복은 스냅샷 기반, 쓰기 비용 큼)
- **키-값 동시 접근**: `ConcurrentHashMap` (반복자는 weakly-consistent, CME 없음)
- **동기화 래퍼**: `Collections.synchronizedList(list)` 사용 시, **반복 범위를 전체 동기화** 해야 안전
  ```java
  List<String> syncList = Collections.synchronizedList(list);
  synchronized (syncList) {
    for (String s : syncList) { /* 안전한 순회 */ }
  }
  ```

---

## 7) 자주 하는 실수 & 안티패턴
```java
for (String s : list) {
  list.removeIf(x -> x.equals("b")); // ❌ 이미 순회 중에 구조 변경 → CME 가능
}
```
- `removeIf`는 **단독으로** 사용하거나, 그 루프 자체를 대체해야 함.
- `Arrays.asList(...)` 결과(고정 크기)나 `unmodifiableList`에서 `remove` → `UnsupportedOperationException`(CME 아님).

---

## 8) 체크리스트
- for-each/stream 순회 중 `add/remove/clear/put` 했나? → **반복자 API로 변경**
- 외부에서 동시에 같은 컬렉션을 수정하나? → **동시성 컬렉션/전체 동기화**
- 콜백이 컬렉션을 만지나? → **스냅샷 순회**
- 대량 필터링 필요? → **`removeIf`** 또는 **새 컨테이너로 수집 후 교체**

---

## 10) 느낀 점 
- 향상된 for문이 기존 반복문의 완전한 상위호환이라고 생각했고, 내부 동작 원리를 모른 채 사용해 ConcurrentModificationException을 겪었다.  
  이번 경험을 통해 어떤 문법이나 기술이든 동작 방식과 원리를 이해한 뒤 적용해야 한다는 점을 깨달았다. 앞으로 더 복잡한 코드와 오류를 마주하더라도, 원리 기반의 접근을 습관화하면 문제를 더 빠르고 정확하게 해결할 수 있다는 생각이 들었다.
  
---
