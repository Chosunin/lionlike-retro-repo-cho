# 250827 회고

## Q1. 오늘 배운 것 중 기억에 남는 것, 어려웠던 것

### 1. hashCode 와 equals

Object 클래스 수업을 듣던 중 강사님이 **equals()** 메소드를 오버라이드 한다면, **hashCode()** 메소드도 함께 오버라이드 되어야 한다. 이렇게 말했다. 그 이유를 정확히 다시 알아보자.  
일단 **equals**만 오버라이딩하게 되면 어떤 문제가 생길까?  
우선 기본 Object 클래스의 **equals**랑 **hashCode** 를 보자  

**기본 equals**  
Object.equals()는 참조 동일성(==)만 비교 → 같은 객체일 때만 true  

**기본 hashCode**  
Object.hashCode()는 JVM이 메모리 주소 기반으로 계산한 정수 반환  

즉 Object 클래스의 **equals**는 같은 객체일 때 true를 만든다  
하지만 우리가 재정의한 **equals**의 경우에는 실제 주소값이 다르더라도 논리적으로 일치한다면 같은 객체라고 정의했다. 아래의 코드가 그 예이다.  


```
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Person)) return false;
    Person p = (Person) o;
    return age == p.age && Objects.equals(name, p.name);
}
```

이러면 어떤 점이 생길까  
Person a 의 name "aaa" age =10;  
Person b 의 name "aaa" age =10; 가 있다고 생각해보자 둘은 논리적으로 일치한 사람이다. 그렇다면 우리가 재정의한 **equals**에 의해서 true를 반환한다.  

이 때 **hashCode**를 재정의 하지 않았다면 어떻게 될까? 다시 기본 **hashCode**를 보자  

**기본 hashCode**  
Object.hashCode()는 JVM이 메모리 주소 기반으로 계산한 정수 반환  

이 점에 의하면 둘은 논리적으로 같은 객체지만 실제로는 물리적으로 다른 객체이다. 그러므로 재정의하지 않았다면 논리적으로 같은 객체이지만 **hashCode**가 달라서 다른 버킷에 들어가게 되어 **equals** 검사까지 도달하지 못하게 되고  
결과적으로 중복이 제거되지 않고 해쉬 컬렉션에서 잘못된 동작이 발생하는 것이다.  

**hashCode**는 HashMap이나 HashSet 객체가 들어갈 버킷(슬롯)을 결정하는 데 사용된다. 또한 Hash 기반 컬렉션(Set/Map)에서는 Key의 중복 여부를 **hashCode + equals**로 판단한다.  

다시 우리는 **hashCode**를 재정의하지 않았다는 점을 기억하자. 논리적으로는 일치하지만 실제로는 다른 **hashCode**를 가졌기 때문에 해쉬 기반 컬렉션에서 중복 제거 기능이 깨지게 된다.  
이 점을 방지하기 위해서 우리는 **equals**를 재정의 했다면 **hashCode**를 다시금 작성하는 것이다.  
`Objects.hash(필드, 필드...)` 이런 식으로 말이다.  

---

### 2. String, StringBuffer, StringBuilder

**String**  
- 불변(immutable)  
- 한 번 생성되면 값이 변하지 않음  
- `"abc" + "d"` → 새로운 String 객체를 만들어냄  

장점:  
- 불변이라서 스레드 안전(thread-safe)  
- 문자열 상수 풀(String Pool)을 활용해 재사용 가능  

단점:  
- 문자열 변경이 자주 일어나면 매번 객체가 새로 생겨서 비효율적  
- 예:  
  ```java
  String a = "aaa";
  a.concat("bbb"); // "aaa"는 그대로, "aaabbb"는 새로운 String


---

**StringBuffer**  
장점:  
- 가변(mutable)  
- 내부적으로 버퍼(배열)에 문자열을 담고, 수정 시 같은 객체 안에서 조작  
- 스레드 안전(thread-safe)  
- 메서드들이 synchronized로 구현돼 있음 → 멀티스레드 환경에서도 안전  

단점:  
- 동기화(synchronization) 때문에 단일 스레드에서는 성능이 느릴 수 있음  

---

**StringBuilder**
장점:  
- 가변(mutable)  
- 구조는 StringBuffer와 동일  
- 단일 스레드 환경에서 문자열 조작이 많을 때 가장 빠름
단점:  
- 스레드 안전하지 않음  
- 동기화 처리가 없어서 멀티스레드 환경에서는 주의 필요  


---

## Q2. 오늘 수업과 회고시간에 대한 느낀 점

- 오늘 회고 시간에 Enum을 주제로 발표했다.  
그동안 내가 접했던 Enum 활용은 주로 Day 같은 간단한 예제 수준이었기에 실무에서 이게 과연 얼마나 고도화될 수 있을까? 하는 의문이 있었다.  
하지만 Enum에 다형성을 결합해 확장하는 방식과 실제 실무 코드 예시를 접하니 단순한 집합 보다 강력한 도구라는 걸 이해할 수 있었다.  
이번 경험을 통해 단순히 개념을 아는 것에 그치지 않고 기술이 어떤 방식으로 실질적으로 응용될 수 있는지 고민하고 탐구하는 과정이 개발자로서 내가 해야 할 중요한 역할이라는 생각이 들었다.  
