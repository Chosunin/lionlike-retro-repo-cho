# 250826 회고

## Q1. 오늘 배운 것 중 기억에 남는 것, 어려웠던 것

### 1. 다형성(Polymorphism) 활용 예시
```public interface PaymentGateway {
    void pay(int amount);
}

class KakaoPay implements PaymentGateway {
    @Override
    public void pay(int amount) { System.out.println("카카오 결제"); }
}

class TossPay implements PaymentGateway {
    @Override
    public void pay(int amount) { System.out.println("토스 결제"); }
}

class PaymentService {
    private final PaymentGateway gateway;
    public PaymentService(PaymentGateway gateway) { 
        this.gateway = gateway;  // KakaoPay인지 TossPay인지 알 필요 없음
    }
    public void process() { gateway.pay(1000); }  // 다형성 활용
}
```
- 위 코드는 **다형성을 활용한 사례** 이다.  
- 공통 기능(`pay`)을 인터페이스로 선언하고, 각 결제 수단이 이를 구현한다.  
- `PaymentService`는 `PaymentGateway` 인터페이스에만 의존하기 때문에,  
  새로운 결제 수단이 추가되거나 기존 구현체가 바뀌어도 **코드 수정이 필요 없다.**

#### 💡 이점

1. **구현체를 몰라도 된다**  
   - `PaymentService`는 오직 `PaymentGateway` 타입만 알면 된다.  
   - 카카오, 토스, 네이버페이 등 어떤 구현체가 들어와도 `pay()`만 호출하면 된다.  

2. **의존성 감소 (느슨한 결합)**  
   - `PaymentService`는 특정 클래스(KakaoPay 등)에 직접 의존하지 않는다.  
   - 구조가 바뀌어도 서비스 레벨에는 영향이 없다.  

---

### 2. 추상 클래스와 인터페이스

#### 인터페이스 (Interface)
- **의도**: 역할(규약, contract) 정의  
- **특징**
  - 모든 메서드는 기본적으로 `public abstract`  
  - 자바 8 이후 `default`, `static` 메서드도 가질 수 있음  
  - 다중 구현 가능 → 유연성 ↑  
  - 상태(필드)는 가질 수 없음 (`public static final` 상수만 가능)  
- **예시**: `PaymentGateway`, `Repository`, `Runnable`  

#### 추상 클래스 (Abstract Class)
- **의도**: 공통 뼈대 + 일부 규약 강제  
- **특징**
  - 추상 메서드는 반드시 구현해야 함  
  - 일반 메서드도 가질 수 있어 공통 로직 제공 가능  
  - 상태(필드) 가질 수 있음  
  - 단일 상속만 가능 (유연성 ↓)  
- **예시**: `HttpServlet`, `BaseEntity`(공통 필드), 템플릿 메서드 패턴  

#### 순수 일반 클래스 상속
- **의도**: 확장 — 기존 클래스(A)를 단독으로 잘 쓰다가, 특수화된 클래스(B)가 필요할 때  
- **특징**
  - 부모 클래스는 원래 완전한 객체 (단독으로 `new` 가능)  
  - 자식 클래스가 추가 기능을 확장하거나 일부 메서드 재정의  
  - 코드 재사용 목적이 크지만, 남용 시 결합도 ↑  
- **사용 빈도**: 드물다 (대부분 인터페이스/추상화/조합으로 대체 가능)  
- **그래도 쓰는 경우**
  - 자바 표준 라이브러리: `InputStream → FileInputStream`, `BufferedInputStream`  
  - 특정 도메인 모델이 진짜 `is-a` 관계일 때만 (`User → AdminUser`)  
- **단점**
  - 단일 상속 제약  
  - 부모 변경 시 자식 전체 영향 → 유지보수 리스크  

---

## Q2. 오늘 수업과 회고시간에 대한 느낀 점

- 내가 헷갈렸던 부분은 **순수 일반 클래스 상속과 추상화**였다.  
  말로만 들으면 일반 클래스 상속에서 할 수 있는 일은 추상화로도 다 대체할 수 있는 것 같았다.  
  실제로 설계만 잘 되어 있다면 순수 일반 클래스 상속을 쓸 일은 거의 없다고 느꼈다.  
  하지만 찾아보니, 기존 클래스를 잘 쓰다가 **특수화된 클래스가 필요할 때** 일반 상속을 쓰기도 한다.  
  즉, **완벽하게 is-a 관계일 때**에만 일반 클래스 상속이 적절하다.  
  만약 `A` 클래스와 `B` 클래스가 있고, 공통 기능이 있으며 `A`만의 특별 기능이 있다면,  
  → 공통 기능만 추상화로 선언하고, 각 클래스 내부에서 고유 기능을 구현하는 방식이 적절하다.  
