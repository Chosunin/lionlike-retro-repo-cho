# 250826 회고

## Q1. 오늘 배운 것 중 기억에 남는 것, 어려웠던 것

### 1. FileReader 
-  역할: 파일에서 문자 단위로 데이터를 읽는 기본 클래스.
-  바이트가 아니라 문자(char) 기반이라, 텍스트 파일을 읽을 때 적합.
-  read() 메서드는 한 문자씩, read(char[] cbuf)는 배열 단위로 읽음.
-  단점: 성능이 떨어짐(매번 파일 시스템에 접근해서 읽기 때문에 느림).

---

### 2. BufferedReader

-  FileReader 같은 Reader 계열을 버퍼링 처리해서 효율적으로 읽도록 돕는 클래스.
-  내부적으로 버퍼(기본 8KB)를 두고 데이터를 모아서 읽기 때문에 속도 개선.
-  readLine() 메서드를 제공 → 한 줄 단위로 읽기가 쉬움.
- FileReader와 함께 많이 사용됨 ```BufferedReader br = new BufferedReader(new FileReader("file.txt"));```

### 3. PrintWriter
- 역할: 파일이나 콘솔에 데이터를 문자 기반으로 출력하는 클래스.
- System.out.println()과 비슷한 print(), println() 메서드를 제공.
- 자동 flush 옵션을 주면 버퍼가 찼을 때나 줄바꿈 시 자동으로 비움.
 
---
### 입력(Reader 계열)
```
[물리적 데이터: 파일, 키보드, 네트워크] 
    ↓ (바이트 스트림)
FileInputStream / System.in / Socket.getInputStream()
    ↓ (바이트 → 문자 변환)
InputStreamReader (인코딩 처리)
    ↓ (효율, 기능 추가)
BufferedReader (readLine, 버퍼링)
```

### 출력(Writer 계열)
```
[내가 쓰고자 하는 대상: 파일, 콘솔, 네트워크] 
    ↓
FileWriter / OutputStreamWriter(new FileOutputStream(...))
    ↓ (편의 기능)
PrintWriter (println, printf, autoFlush 등)
    ↓ (효율)
BufferedWriter (버퍼링, newLine())
```
## Q2. 오늘 수업과 회고시간에 대한 느낀 점

- I/O는 계층적으로 쌓여 있다는 것  
파일/키보드/소켓 같은 물리적 데이터 소스 → InputStream/OutputStream (바이트) → Reader/Writer (문자 변환) → BufferedReader/PrintWriter (편의 기능, 성능).  
이 흐름을 이해하니 코드가 단순한 게 아니라 “데코레이터 패턴” 구조라는 걸 알 수 있었다.  
- 파일 경로 처리의 중요성  
단순히 "test.txt"라고 쓰면 현재 작업 디렉토리를 기준으로 저장되며, 경로 문제 때문에 에러가 잘 발생한다.
앞으로는 System.getProperty("user.dir")를 확인하고, File 객체를 활용해 안전하게 경로를 관리하는 습관을 들여야겠다.
이것들에 익숙해지는 게 필요할 것 같다.  
한 번 코드를 짜보고 끝내는 게 아니라, 여러 번 반복하면서 BufferedReader, PrintWriter, FileWriter 등을 자연스럽게 연결할 수 있게하고 특히 try-with-resources 구문으로 자원 관리를 안전하게 하는 습관을 연습해야겠다.  
