### 오늘 배운 내용 중 가장 기억에 남는 것
#### DAO 패턴 (Data Access Object) 활용
DAO는 데이터베이스에 접근하는 전용 객체이고, DTO(Data Transfer Object)는 데이터를 담는 객체다.  
DeptDTO 같은 객체는 단순히 데이터를 담는 역할만 하고, DeptDAO는 이 데이터를 이용해서  
DB에 INSERT, UPDATE, DELETE, SELECT 쿼리를 실행한다.

예를 들어, 아래처럼 main 메서드에서 직접 SQL을 실행하지 않고 DAO를 호출하는 방식이다.  
```java
DeptDTO insertDTO = new DeptDTO();
insertDTO.setDeptNo(50);
insertDTO.setDname("LION");
insertDTO.setLoc("SEOUL");
dao.insertDept(insertDTO);  // 실제 SQL 실행은 DAO 내부에서 처리
```
이렇게 하면 main 코드에는 SQL이 보이지 않고, DAO 내부에서만 SQL을 관리할 수 있다.  
SQL과 비즈니스 로직이 분리되어 유지보수가 쉬워지고, 같은 DAO 메서드를 여러 곳에서 재사용할 수 있다.

***

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것
#### 단건 조회 시 return 값 (빈 객체 vs null)
오늘 헷갈렸던 부분은 DAO에서 단건 조회를 할 때, 해당 데이터가 존재하지 않을 경우  
빈 DTO 객체를 리턴하는게 나은지, null을 리턴하는게 나은지에 대한 대답이었다.  
처음에 빈 객체를 리턴한다고 대답했는데 잘못 생각했었다.  

- 빈 객체 리턴
```java
DeptDTO dto = new DeptDTO(); 
// 값이 없으면 빈 상태로 리턴
return dto;
```
장점: NullPointerException 방지 가능  
단점: 호출하는 쪽에서 if (dto != null)만 확인해도 끝날 일을  
`if(dto != null && dto.getDeptNo() != 0)` 같이 “객체 존재 여부 + 내부 값 존재 여부”를 이중으로 확인해야 한다.


- null 리턴
```java
if (rs.next()) {
    DeptDTO dto = new DeptDTO();
    dto.setDeptNo(rs.getInt("deptno"));
    return dto;
}
return null;
```
장점: 호출하는 쪽에서 단순히 if(dto != null)만으로 데이터 존재 여부 확인 가능  
단점: null을 바로 쓰면 NullPointerException 위험이 있으므로 반드시 체크가 필요

>불필요한 중복 체크를 줄이기 위해 null을 리턴하는 게 더 낫다는 점을 배웠다.

***
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)

- [블로그에 작성한 TIL](https://velog.io/@daheenamic/멋사-19기-백엔드-TIL-Database-JDBC)

```text 
DAO와 DTO 패턴을 직접 구현하면서,
객체를 어떻게 다뤄야 하는지에 따라 코드의 가독성과 안정성이 달라진다는 걸 느꼈다.
작은 차이(빈 객체 vs null 리턴)가 실제로는 호출부 코드 구조에 큰 영향을 주는 것을 보고,
설계 단계에서의 선택이 중요하다는 걸 깨달았다.
또한 단순 CRUD만 해도 코드가 중복되고 길어지는데,
이런 이유 때문에 MyBatis나 JPA 같은 ORM 프레임워크가 필요하다는 것도 더 명확히 이해하게 되었다.
```

