### 오늘 배운 내용 중 가장 기억에 남는 것
#### SOLID 원칙

SOLID는 객체지향 설계에서 자주 언급되는 다섯 가지 원칙의 약자로, 코드의 유지보수성과 확장성을 높이기 위해 사용된다.  
1. SRP (단일 책임 원칙): 클래스는 하나의 책임만 가져야 한다.
2. OCP (개방-폐쇄 원칙): 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.
3. LSP (리스코프 치환 원칙): 자식 클래스는 부모 클래스를 대체할 수 있어야 한다.
4. ISP (인터페이스 분리 원칙): 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않도록 인터페이스를 잘게 나누어야 한다.
5. DIP (의존 역전 원칙): 구체적인 구현이 아니라 추상화(인터페이스, 상위 클래스)에 의존해야 한다.

***

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것

다섯 가지 원칙 중에서 가장 헷갈렸던 것은 **DIP(의존 역전 원칙)**이다.  
상위 모듈이 하위 모듈에 의존하지 말고, 둘 다 추상화에 의존해야 한다라는 문장이 추상적으로 느껴졌다.  
예를 들어 `MessageSender` 클래스가 `EmailService` 같은 구체적인 클래스에 직접 의존하면 결합도가 높아진다.  
하지만 `MessageService`라는 인터페이스를 두고,  
`EmailService`나 `SmsService`가 그 인터페이스를 구현하면, `MessageSender`는 인터페이스에만 의존하게 된다.  
이렇게 하면 새로운 메시지 전송 방식이 추가되더라도 `MessageSender` 코드를 수정하지 않아도 되는데, 이 부분을 실제 코드로 이해하는 게 조금 어려웠다.  

```java
// 추상화(인터페이스)에 의존
interface MessageService {
    void sendMessage(String msg);
}

// 구체 클래스 1
class EmailService implements MessageService {
    @Override
    public void sendMessage(String msg) {
        System.out.println("Email: " + msg);
    }
}

// 구체 클래스 2
class SmsService implements MessageService {
    @Override
    public void sendMessage(String msg) {
        System.out.println("SMS: " + msg);
    }
}

// 상위 모듈: 구현체가 아니라 인터페이스에 의존
class MessageSender {
    private final MessageService messageService;

    // 생성자 주입
    public MessageSender(MessageService messageService) {
        this.messageService = messageService;
    }

    public void send(String msg) {
        messageService.sendMessage(msg);
    }
}

public class Main {
    public static void main(String[] args) {
        MessageSender emailSender = new MessageSender(new EmailService());
        emailSender.send("Email~");

        MessageSender smsSender = new MessageSender(new SmsService());
        smsSender.send("SMS~");
    }
}
```


***
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)

- [블로그에 작성한 TIL](https://velog.io/@daheenamic/멋사-백엔드-19기-Java-Solid-원칙)

```text 
오늘 배운 내용에서 내가 아직 SOLID 원칙을 머리로는 이해했지만,  
실제 코드에 적용하려면 더 많은 연습이 필요하다는 걸 느꼈다.  
특히 DIP는 개념만 보면 단순해 보이지만, 막상 코드로 짜려 하면 의존성을 어떻게 분리할지 감이 잘 안 잡혔다.  
앞으로는 작은 예제를 직접 만들어 보면서 패턴을 몸에 익히는 게 필요하다고 생각했다.
원칙을 외우는 것보다 “왜 필요한가”를 이해하는 게 더 중요하다는 걸 알게 됐다.  
원칙은 규칙처럼 억지로 지켜야 하는 게 아니라, 유지보수를 편하게 하고 코드의 유연성을 높이기 위한 도구라는 걸 명확히 인식해야겠다.

그리고 회고시간에는 다같이 평가문제를 풀어보고, 풀이하는 시간을 가졌다.  
덕분에 내가 틀린 문제에 대해서 왜 틀렸는지 명확하게 알 수 있었고,  
그리고 제대로 알지 못하면서 맞춘 문제에 대해서도 왜 맞췄는지도 알 수 있어서 유익한 시간이 되었다.
```

