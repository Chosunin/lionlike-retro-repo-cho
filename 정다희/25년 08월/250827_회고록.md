### 오늘 배운 내용 중 가장 기억에 남는 것

#### 1. 열거형(Enum)
- class를 만들어서 상수를 나열할 수 있지만 `enum`을 사용하면 허용된 값만 타입으로 강제 할 수 있다.

| 구분     | enum | class |
|--------| --- | ---- |
| 목적     | 유한한 값 집합(상태/코드/권한 등)을 **타입으로 강제** | 임의의 객체 설계(인스턴스 무한 생성 가능) |
| 인스턴스 수 | **상수 개수만큼 고정**(각 상수 = `public static final` 단일 객체)  | `new`로 마음대로 생성 |
| 생성자    | 암묵적으로 `private`; 외부에서 `new` 불가 | 보통 `public/protected`; 외부에서 `new` 가능 |
| 상속     | 이미 `java.lang.Enum` 상속 → **다른 클래스 상속 불가**. 인터페이스 **구현은 가능** | 다른 클래스 상속/인터페이스 구현 **가능**(제한 없음) |
| 비교     | `==`로 안전 비교 가능(싱글턴 보장)| `==`는 참조 비교, 보통 `equals()` 재정의 필요 |
| 기능     | `values()`, `valueOf()`, `switch`에 자연스러운 사용, 각 상수에 **필드/메서드** 가질 수 있음 | 이런 유틸 없음(직접 구현) |
| 타입 안전성 | **허용된 상수만** 변수에 담김 → 컴파일 타임에 오류 발견 | 어떤 값(문자열/숫자)도 들어올 수 있음(런타임 검증 필요) |
| 직렬화    | 이름 기반으로 안전(상수명 유지 시 호환)| 구현 방식에 따라 다름 |
| 대표 사용  | 주문상태, 권한, 에러코드, 방향 등 **유한 상태** | 엔티티/서비스/DTO 등 일반 도메인 객체 |

#### 2. StringBuilder와 StringBuffer
String객체가 한 번 만들어지면 바뀌지 않는 불변 객체라는 걸 처음 알았다.  
이걸 몰랐으니니 StringBuilder나 StringBuffer를 쓰는 이유를 모르고 있었다.  
`concat`, `replace`, `substring`, `toUpperCase` 이런 메서드들은  
겉보기에는 수정되는 것 같이 보이지만 사실 새로운 객체를 만들어 저장한다.  
Builder는 단일스레드에서 쓰이고, Buffer는 멀티스레드에서 사용된다. 

- ❌ **안 좋은 예시**
```java
String s = "";
for (int i = 0; i < 5000; i++) {
    s += i; // 매번 새 String 생성 → 느림
}
```
- ✅ **좋은 예시**
```java
StringBuilder sb = new StringBuilder(10000); // 대충 예상 길이 잡아주면 더 좋음
for (int i = 0; i < 5000; i++) {
    sb.append(i);
}
String s = sb.toString();
```

***

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것

#### 1. `equals()`와 `hashCode()` 메서드
equals()와 hashCode() 메서드를 만들어야 하는 이유에 대해 정확히 와닿지가 않았었다.  
아직 배우진 않았지만 해시 기반 컬렉션인 `HashMap`과 `HashSet` 규약 때문이라고 한다.  
`a.equals(b) == true`이면 `a.hashCode() == b.hashCode()`이어야 `HashSet`/`HashMap`이 같은 객체라고 판단 하기 때문이다.  
같은 객체라고 판단 하지 못하면 중복 저장하거나 키를 못 찾는 문제가 생긴다.

```java
class User {
    String id;
    User(String id){ this.id = id; }

    @Override
    public boolean equals(Object o) {
        return (o instanceof User u) && Objects.equals(id, u.id);
    }
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
```

***
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)

- [블로그에 작성한 TIL](https://velog.io/@daheenamic/멋사-19기-백엔드-TIL-Java-객체지향-final클래스-열거형-내부-클래스)

```text
오늘 회고 발표는 개념 설명 반, 코드 만들어보기 반 해서 회고를 진행했다.
나는 코드 설명을 맡았는데 오늘 회고에서 좋았던 점은 앞서 개념을 발표했던 팀원의 발표를 보고
코드 발표를 맡았던 팀원이 그걸 넣어서 발표를 했던 부분이다. 
그리고 만들어진 코드로 내가 추가해보고 하는 그런 시간을 가졌더니 다른분들이 어떤식으로 
클래스를 확장하고 메서드를 활용하는지 볼 수 있는 기회가 되어서 좋았다.
그리고 String과 StringBuilder, StringBuffer의 성능을 직접 눈에 보이게 발표해주신 팀원분 덕에
조금 더 이해가 쉬웠고 유익한 회고 시간이었다.
앞으로 다른 팀원들도 코드를 만들어보는 발표의 비중을 늘리는게 좋을 것 같다.
개념도 중요하지만 코드는 계속 많이 만들어보고 오류도 나보고 고쳐나가보는데 엄청 중요하다고 생각하기 때문이다.
```

