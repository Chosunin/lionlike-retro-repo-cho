### 오늘 배운 내용 중 가장 기억에 남는 것

#### 추상클래스와 인터페이스의 차이점
| 구분 | 추상 클래스 | 인터페이스  |
| --- | ---| ---|
| 상속 | **단일 상속만 가능** | **다중 구현 가능** |
| 목적  | “공통된 뼈대 + 기본 동작 제공” | “규칙만 정의” |
| 구성 요소 | 필드, 생성자, 일반 메서드, 추상 메서드 포함 가능| (원래는 추상 메서드만, Java 8+부터 `default`/`static` 메서드 가능) |
| 상태(state) | 인스턴스 변수 가질 수 있음  | 인스턴스 변수 없음 (상수만 가능: `public static final`)|
| 언제 쓰나 | - 공통 코드 제공하면서 일부만 자식에게 위임하고 싶을 때<br>- **템플릿 메서드 패턴** | - 다형성 규칙만 정의할 때<br>- 서로 관련 없는 객체들도 같은 "기능" 강제할 때|

#### JDK 8 버전에 추가된 인터페이스 메서드
- `default` 키워드를 메서드 앞에 붙이면 구현부가 있는 메서드를 정의할 수 있다.
- `static` 메서드는 인터페이스 이름으로 직접 호출하여 사용 가능하다.

#### `instanceof`
- 특정 클래스나 인터페이스를 구현하고 있는지 궁금할 경우
```java
if(animal instanceof Dog) {
	Dog dog = (Dog) animal;
    dog.wagTail();
}
```

***

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것

#### 인터페이스에 같은 default 메서드가 있다면?

인터페이스에 `default` 키웓로 구현부가 있는 메서드가 사용이 가능하면,  
두 개의 다른 인터페이스에서 같은 `default` 메서드가 있을 때 충돌이 날 가능성이 있다.  
```java
interface A {
    default void hello() { System.out.println("A"); }
}
interface B {
    default void hello() { System.out.println("B"); }
}

class C implements A, B {
    @Override
    public void hello() {
        // 한쪽을 선택해서 호출 가능
        A.super.hello(); // 또는 B.super.hello();
        // + 추가 로직 가능
    }
}
```
이럴때는 `super`를 통해 정확한 인터페이스를 지정 해 줘야 한다.  
원래 부모 클래스의 매서드에 접근할 때 `super.test()` 이런식으로 접근하는데  
“특정 인터페이스의 default 메서드”를 직접 호출할 때 쓰는 특수 문법인 `A.super.hello()`를 사용해서  
정확히 어떤 인터페이스의 메서드를 호출할 지 직접 지정을 해주어야 충돌이 나지 않는다.

***
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)

- [블로그에 작성한 TIL](https://velog.io/@daheenamic/멋사-19기-백엔드-TIL-Java-객체지향-추상클래스-인터페이스)

```text
오늘도 정신 없이 지나간 하루였다.
일단 저번주에 배운 상속을 다시 복습을 하고 추상클래스와 인터페이스에 대해 방대한 양을 짧은 시간내에 배웠다.
오늘도 자바의 정석을 뒤적거리고 GPT를 괴롭히면서 하루를 보냈다.
회고시간에 팀원들과 이야기를 나누어보니 다들.. 각자만의 싸움을 하고 있는 것 같았다.
회고시간이 좋은 이유가 수업을 듣는 내내 나 혼자만의 싸움을 하다가 회고시간이 되면 팀원들과
같이 공감하고 이야기 나누면서 이런 저런 정보도 새로 알게되어서 좋은 것 같다.
```

