### 오늘 배운 내용 중 가장 기억에 남는 3가지
1. **자동형변환의 원리**
```java
byte b = 10; // byte: -128 ~ 127 (1바이트)
int i = b;   // int: -2,147,483,648 ~ 2,147,483,647 (4바이트)
// ✅ 자동형변환 가능: 작은 범위 → 큰 범위
```
그러나, `b = i;` 라고 하면 오류 발생. <br>
이유 : int(4바이트)를 byte(1바이트)에 넣으면 데이터가 잘릴 수 있다.<br>
`int i = b;` 에서는 그냥 b가 자동형변환 되어 그 값이 i에 들어갔을 뿐이지,<br>
b라는 변수의 타입이 바뀐것이 아니기 때문에 오류가 발생한다.<br>

2. **캐리지리턴(\r)**
: 이스케이프 시퀀스중에 다른건 다 알고 있었는데 `\r` (캐리지리턴)을 처음 봤다.
```java
System.out.println("1\n2\r3"); // 출력결과 : 1\n3
```
출력결과가 1하고 3밖에 나오지 않아서 의아해서 뭔가 찾아봤더니 2를 출력 후,<br>
커서가 현재줄의 맨 앞으로 이동 한 다음 3일 출력되면서 같은 줄에 있던 2를 덮어 씌웠다.<br>
왜 이런게 필요한가 싶었는데 보통 진행률을 표시할 때 같은 줄에서 계속 10%.. 20%.. 하고 업데이트 해야 할 때 쓴다고 한다.<br>
알아두면 좋을 것 같아서 코드 예제를 적어두었다.
```java
// 진행률 표시 예제
for (int i = 0; i <= 100; i += 10) {
    System.out.print("다운로드 진행률: " + i + "%\r");
    
    // 실제로는 다운로드 작업이나 처리 시간
    try {
        Thread.sleep(500); // 0.5초 대기
    } catch (InterruptedException e) {}
}
System.out.println("완료!"); // 마지막에 줄바꿈
```
3. **스택(Stack)과 힙(Heap)**
- 스택(Stack)에는 프레임이 하나 씩 쌓이고, 힙(Heap)에는 `new`로 생성한 객체가 저장되는 공간 이라는 것
- 기본타입은 stack에 쌓이고, 참조타입은 Heap에 쌓인다.

***

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것 3가지
1. `printf`를 잘 사용하지 않아서, 서식 지정자가 헷갈린다. (`%s`, `%d` 등..)
2. `switch`문에 `break`를 절대 까먹지 말자..!
3. 오랜만에 `Scanner`를 써서 스캐너 객체 생성방법을 다 잊어버렸지만 팀원분들께 설명하며 다시 상기 시켰다. 

***
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)
- 변수를 선언하고 초기화 하는 것은 코드를 쓸 때 무의식적으로 많이 하지만, 어떤 경우에 기본타입을 쓰고 어떤 경우에는 참조 타입을 쓰는지 명확히 쓰임새를 구분하지 않고 쓰고 있었다. 그래서 오늘 강의 시간에 변수에 대한 정의를 확실히 배우고 정리해서 이제 코드를 작성할 때 명확하게 구분을 할 수 있을 것 같다. 조건문이 나온 이후로 따라오는것을 다소 어려워하는 팀원분들도 계셨지만 나는 내가 처음 배울때 차근 차근 설명해 주는 사람이 없었어서 많은 어려움을 겪었기 때문에 최대한 내가 설명할 수 있는 부분은 이해가 될 때 까지 설명을 해드리고 싶다. 회고 3조가 언제까지 팀을 이룰지는 모르겠지만, 내가 안다고 넘어가거나 그러지 않고 최대한 회고시간에 하나하나 짚어가면서 나도 다시 배우는 계기가 되고, 낙오되거나 포기하는 팀원이 없도록 팀장으로써의 역할을 더 잘 해야겠다고 생각했다. 그리고.. 코테 좀 시작하자. 내일부터는 꼭!
