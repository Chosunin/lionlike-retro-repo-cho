## 250827 회고록


### 오늘 배운 내용 중 가장 기억에 남는 3가지

1. **StringBuilder 와 StringBuffer** <br>

* StringBuilder : 동기화 지원 X → 멀티스레드 환경에서는 안전하지 않음
    - 한 번에 하나의 작업만 처리 → 앞 작업이 끝나야 다음 작업 실행
    - 단일 스레드 환경에서 사용 시 가장 빠른 성능 제공
* StringBuffer : 동기화 지원 O → 멀티스레드 환경에서도 안전
    - 여러 작업을 동시에 처리 → 효율적이지만, 스레드끼리 충돌하지 않도록 동기화 필요
    - 동기화를 위해 락(lock)을 걸기 때문에 오버헤드 발생 → 단일 스레드에서는 Builder보다 느림

```java
public class StrBuildAndBuffer {
    public static void main(String[] args) {
        int loop = 50000;
        long start, end;

        // String (불변 → 매번 새 객체 생성 → 가장 느림)
        start = System.currentTimeMillis();    // 시작시간
        String str = "";
        // loop 만큼 돌려서 시간지연 발생시키기
        for (int i = 0; i < loop; i++) {
            str += "a";
        }
        end = System.currentTimeMillis();     // 종료시간
        System.out.println("String 걸린 시간: " + (end - start) + "ms");

        // StringBuilder (가변, 동기화 X → 빠름)
        start = System.currentTimeMillis();   // 시작시간
        StringBuilder sb = new StringBuilder();
        // loop 만큼 돌려서 시간지연 발생시키기
        for (int i = 0; i < loop; i++) {
            sb.append("a");
        }
        end = System.currentTimeMillis();    // 종료시간
        System.out.println("StringBuilder 걸린 시간: " + (end - start) + "ms");

        // StringBuffer (가변, 동기화 O → Builder보다 조금 느림)
        start = System.currentTimeMillis();  // 시작시간
        StringBuffer sbf = new StringBuffer();
        // loop 만큼 돌려서 시간지연 발생시키기
        for (int i = 0; i < loop; i++) {
            sbf.append("a");
        }
        end = System.currentTimeMillis();   // 종료시간
        System.out.println("StringBuffer 걸린 시간: " + (end - start) + "ms");
    }
}
```

---

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것 3가지

1. **equals() 과 hashcode() 오버라이딩** <br>
    처음 배울 때 안에 로직이 아예 이해가 안되서 AI 통해 물어보면서 어느정도 이해는 했지만 그래도 어려운 것 같다. 나중에 쓰게된다면 다시 깊게 알아봐야겠다.

```java
// pre code ...

    @Override
    public boolean equals(Object obj) {
        // 자기자신 비교 리턴 - true
        if (this == obj) return true;

        // 비교 대상이 null 이거나, 클래스 타입이 다르면 false
        if (obj == null || getClass() != obj.getClass()) return false;

        // 타입이 같다면 명시적 형변환
        // 형변환 하는 이유는 Object 타입으로 매개변수 받고 있어서 자기 클래스 속성 접근 안됨.
        Pen pen = (Pen) obj;

        // 매개변수 객체와 자기자신과 비교
        return name.equals(pen.name) && code.equals(pen.code) && type.equals(pen.type);
    }

    @Override
    public int hashCode() {
        int result = 17;  // 초기값 (보통 17 사용) ?
        // 각 필드의 해시를 누적
        // 누적 방식: result = 31 * result + fieldHash
        // 누적 시키는 이유 ? -> (abc) != (cba) 처럼 순서 다른것을 고려하여 누적계산
        result = 31 * result + (name != null ? name.hashCode() : 0);
        result = 31 * result + (code != null ? code.hashCode() : 0);
        result = 31 * result + (type != null ? type.hashCode() : 0);
        return result;

        // 또는
        // import java.util.Objects
        // return Objects.hash(name, code, type);
    }
    
// next code ...
```

    

---
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)

오늘도 강의가 많이 어려웠던 것 같다. <br>
이해가 잘안되서 강의도중 AI한테 많이 물어보고 하느라 예제코드 타이핑 칠 시간이 많이 부족했다. <br>
틈틈히 복습해야겠다.