## 250828 회고록


### 오늘 배운 내용 중 가장 기억에 남는 3가지

1. 컬렉션 프레임워크
```bash
# 프레임워크 계층 구조
Iterable
└── Collection
    ├── List
    │   ├── ArrayList
    │   ├── LinkedList
    │   ├── Vector
    │   └── Stack   # (Vector의 하위 클래스)
    ├── Queue
    │   ├── PriorityQueue
    │   └── Deque
    │       └── ArrayDeque
    └── Set
        ├── HashSet
        ├── LinkedHashSet
        └── SortedSet
            └── TreeSet

Map
├── HashMap
│   └── LinkedHashMap
└── HashTable

SortedMap
└── TreeMap
```

* 인터페이스 : `Iterable`, `Collection`, `List` , `Queue`, `Map`
* 클래스 : `ArrayList`, `LinkedList`, `HashSet`, `LinkedHashSet`, `HashMap` ....
* 해당 계층 구조 이미지로 확인
    - [TIL 개인블로그](https://starweb.tistory.com/15#17)


2. 컬렉션 프레임워크 주요 인터페이스

```java
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;

// List - 순서보장O, 중복허용O
List<String> list = new ArrayList<>();

// Set - 순서보장X, 중복허용X 
Set<String> set = new HashSet<>();

// Map - key-vaule 형태 | key중복X, value중복O, 순서보장X
Map<String, String> map = new HashMap<>();

// Map 순서보장할 경우 (삽입순서 유지)
Map<String, String> map = new LinkedHashMap<>();
```
---

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것 3가지

1.Map 일반 접근 방식과 Map 엔트리 접근 방식 차이

* 일반 접근 방식
```java
// 기존 방식: keySet()과 get()을 이용한 접근
Map<String, String> map = new HashMap<>();
map.put("key1", "1");
map.put("key2", "2");
map.put("key3", "3");

for (String key : map.keySet()) {
    String value = map.get(key);  // key로 다시 value 조회
    System.out.println(key + " = " + value);
}
/**
 * key1 = 1
 * key2 = 2
 * key3 = 3 
 */
```

* 엔트리 접근 방식
```java
// 엔트리 접근 방식 : key와 value를 한 번에 가져옴
Map<String, String> map = new HashMap<>();
map.put("key1", "1");
map.put("key2", "2");
map.put("key3", "3");

for (Map.Entry<String, String> entry : map.entrySet()) {
    String key = entry.getKey();
    String value = entry.getValue();
    System.out.println(key + " = " + value);
}
```

해당 방법을 보면 <br>
일반 접근 방식은 키값 가지고 다시 조회하는 반면, 엔트리는 키 벨류 둘다 동시 접근 가능한 것 같은데 <br>
어떻게 응용할지 크게 감이 오지 않는다.. 계속 써봐야겠다.


2. 중첩된 제네릭

* `List<List<String>>`
```java
List<List<String>> names = new ArrayList<>();

List<String> group1 = new ArrayList<>();
group1.add("짱구");
group1.add("철수");

List<String> group2 = new ArrayList<>();
group2.add("유라");
group2.add("영구");

System.out.printlin(name); 
// [[짱구, 철수], [유라, 영구]]
```

* `Map<String, List<Pen>>`
```java
List<Pen> pen = new ArrayList<>();
pen.add(new Pen("볼펜", "검정"));
pen.add(new Pen("연필", "파랑"));
pen.add(new Pen("샤프", "빨강"));

pen.add(new Pen("연필", "검정"));
pen.add(new Pen("연필", "초록"));

// Map<문자열, List<Pen>>
Map<String, List<Pen>> map = new HashMap<>();

// key 타입 기준 삽입
for (Pen p : pens) {
    String type = p.getType();
    // 해당키 없으면 생성
    if (!colorMap.containsKey(type)) {
        colorMap.put(type, new ArrayList<>());
    }
    // 해당키에 벨류 삽입
    majorMap.get(type).add(p);
}
```

중첩 제네릭을 처음 써봐서 잘 이해가 안되었는데 계속 써보면서 익숙해져야겠다.

---
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)

오늘 개인적인 일로 전화하고 뭐하느라 강의에 크게 집중 못했었다. <br>
그래서 프레임워크 관련 강의때 잠시 자리비움있었는데 순간 넘어가서 ai한테 물어보면서 겨우 따라간 것 같다. <br>
그리고 회고시간에 팀장님 만든 예제 가지고 풀어보는데 코딩하다가 생각보다 어..? 하고 막힌 경우가 있어서 <br>
좀 더 코딩 연습 많이 해야겠다.
