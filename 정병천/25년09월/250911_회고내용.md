## 250911 회고록


### 오늘 배운 내용 중 가장 기억에 남는 3가지

1. 서브쿼리

* 멀티로우 쿼리

```sql
/* in 연산자 : 무조건 '='이고, 내부 값 중 하나라도 만족 */
-- 부하직원이 있는(= 누군가의 mgr로 등록된) 사원만 조회
SELECT empno, ename FROM emp
    WHERE empno IN (
        SELECT mgr
        FROM emp
        WHERE mgr IS NOT NULL   
        -- 여러 행 반환 (매니저 사번들의 집합)
    );


/* any 연산자 */
-- 비교 연산시 any () 안의 값들 중 하나 만족할 경우 = 참
SELECT ename, deptno, sal FROM emp
    -- 30번 부서 사람들 급여보다 하나라도 작을 경우
    WHERE sal > any (
        SELECT sal FROM emp
        WHERE deptno = 30
    );


/* all 연산자 */
-- 비교 연산시 all () 안의 값들 중 전부 만족할 경우 = 참
SELECT ename, deptno, sal FROM emp
    -- 30번 부서 사람들 급여보다 모두 작을 경우
    WHERE sal > all (
        SELECT sal FROM emp
        WHERE deptno = 30
    );
```

* 상관 서브쿼리

```sql
-- 사원의 급여가 자기 부서의 평균 급여보다 큰 경우
SELECT ename, sal, deptno FROM emp e
    WHERE e.sal > (
        SELECT avg(i.sal) FROM emp i
        WHERE i.deptno = e.deptno
        -- 내부부서번호 = 외부부서번호 (대상직원) 일치한 부서의 평균 구하여
        -- 비교함 (외부쿼리 튜플마다)
    );

-- 부서마다 부서 내에서 최고급여 받는 사원
SELECT ename, deptno, sal FROM emp
    -- (부서, 급여) = ( 부서1의 최고급여, 부서2의 최고급여 ...)
    WHERE (deptno, sal) in (
        SELECT deptno, max(sal) FROM emp
        GROUP BY deptno
    );


-- 부서 내 최고 급여를 받고 있는 사원의 모든 정보와 최고급여 컬럼 추가
SELECT e.*, m.max_sal FROM emp e
    JOIN (
        SELECT deptno, max(sal) as max_sal FROM emp
        GROUP BY deptno
    ) m on e.deptno = m.deptno and e.sal = m.max_sal; 
```

서브쿼리 활용해서 좀 더 디테일하게 추출하는 방법을 배웠는데 <br>
활용도가 크고 생각보다 괜찮은 느낌이라 기억에 많이 남았다.

---

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것 3가지

1. join

```sql
/* non-equi join */
SELECT e.ename, e.sal, s.grade FROM emp e, salgrade s
    WHERE e.sal BETWEEN s.min_salary and s.max_salary;
    -- emp.sal 값이 salgrade 테이블의 min_salary ~ max_salary 범위에 속하면 매칭
    -- 조인을 통해 급여 등급 확인 가능

/* outer join */
-- left (좌측 테이블 emp 정보 모두 포함)
SELECT e.ename, e.deptno, d.dname FROM emp e
    LEFT OUTER JOIN dept d USING(deptno);
    -- dept 에 해당부서없으면 dname(부서명) 은 null로 나타남

-- right (우측 테이블 dept 정보 모두 포함)
SELECT e.ename, e.deptno, d.dname FROM emp e
    RIGHT OUTER JOIN dept d USING(deptno);
    -- emp 에 해당 부서 직원이 없으면 ename(직원명) 은 null로 나타남

-- union (두 테이블 합집합)
SELECT e.ename, e.deptno, d.dname FROM emp e
    RIGHT OUTER JOIN dept d USING(deptno)
    UNION
    SELECT e.ename, e.deptno, d.dname FROM emp e
    LEFT OUTER JOIN dept d USING(deptno);
    -- emp 직원, dept 부서 없어도 둘다 합집합으로 null로 나옴
    -- 즉 모든 직원 + 모든 부서 정보 한번에 노출
```

조인으로 합치는게 아직 낯설여서 그런지 전날부터 조인을 배웠는데 아직도 어렵다.<br>
머리속으로는 '아 그렇구나' 라고 이해 되는데 막상 조인을 가지고 활용할 때는 잘 안되서 <br>
연습 하면서 노력해봐야겠다.



---
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)

오늘 회고 시간에는 미니프로젝트를 기반으로 테이블을 직접 설계해보는 시간을 가지게 되었다. <br>
처음에는 어떻게 나눠야 할지 감이 잘 오지 않아 간단히 구상만 잡고 
피드백을 받았었는데 많은 도움을 받아 유익한 시간이었다.
또한 팀원들이 작성한 다양한 쿼리문을 보면서 '저렇게도 할 수 있구나' 하고 새로운 시각을 얻을 수 있어 좋았었다.

