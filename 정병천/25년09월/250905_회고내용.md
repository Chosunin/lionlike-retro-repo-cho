## 0250905 회고록


### 오늘 배운 내용 중 가장 기억에 남는 3가지

1. SOLID 원칙

객체지향 프로그래밍 핵심 원칙. 각 원칙의 앞글자 따서 SOLID

* **S**ingle Responsibility Principle (단일 책임 원칙)
    - 클래스는 하나의 책임
* **O**pen/Closed Principle (개방-폐쇄 원칙)
    - 확장은 열려있고 수정은 닫혀있어야함
* **L**iskov Substitution Principle (리스코프 치환 원칙)
    - 자식은 부모를 대체할 수 있다
* **I**nterface Segregation Principle (인터페이스 분리 원칙)
    - 사용하지 않는 기능에 의존하지 않도록 인터페이스는 작게 분리
* **D**ependency Inversion Principle (의존성 역전 원칙)
    - 구체 클래스가 아니라 추상(인터페이스/상위 타입)에 의존


---

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것 3가지

1. DIP 의존성 역전

* 위 모듈은 하위 모듈의 구현체가 아닌 추상화에 의존해야 한다.

```java
// 메인에서 의존할 인터페이스
interface TV {
    void powerOn();   // 전원 켜기
    void powerOff();  // 전원 끄기
    void volumeUp();  // 볼륨 올리기
    void volumeDown();// 볼륨 내리기
}

// 구현체 1: samsung TV
class STV implements TV {
    private boolean power; 
    private int volume = 50;
    @Override public void powerOn()  { power = true;  System.out.println("samsung TV 켜짐"); }
    @Override public void powerOff() { power = false; System.out.println("samsung TV 꺼짐"); }
    @Override public void volumeUp() { System.out.println("볼륨: " + (++volume)); }
    @Override public void volumeDown() { System.out.println("볼륨: " + (--volume)); }
}

// 구현체 2: LG TV
class LTV implements TV {
    private boolean power; 
    private int volume = 50;
    @Override public void powerOn()  { power = true;  System.out.println("LG TV 켜짐"); }
    @Override public void powerOff() { power = false; System.out.println("LG TV 꺼짐"); }
    @Override public void volumeUp() { System.out.println("볼륨: " + (++volume)); }
    @Override public void volumeDown() { System.out.println("볼륨: " + (--volume)); }
}

// [선택사항] 팩토리 패턴으로 고도화 → 브랜드명에 따른 구현체 생성 분리
class TVFactory {
    public static TV obj(String brand) {
        if (brand.equals("samsung")) return new LTV();
        if (brand.equals("LG")) return new STV();
        throw new IllegalArgumentException("지원하지 않는 브랜드: " + brand);
    }
}

public class TVExam {
    public static void main(String[] args) {
        // 인터페이스 의존 / 구현체 외부주입됨
        Tv tv0 = new STV();
        tv0.powerOn();
        tv0.volumeUp();
        tv0.volumeDown();
        tv0.powerOff();

        // 팩토리패턴
        String brand = "LG"; // 전달 받은 값 예시
        TV tv1 = TVFactory.create(brand);
        tv1.powerOn();     
        tv1.volumeUp();    
        tv1.volumeDown();  
        tv1.powerOff();   
    }
}
```
* 메인 실행에선 TV 인터페이스에만 의존됨
* 실제 구현체(STV, LTV)는 외부에서 주입받음 → 교체와 확장이 용이
    - 팩토리패턴으로 하여금 메인 클래스 수정 없이 가능

DIP(의존관계 역전 원칙) 들으면서 햇갈렸던 점이 생겼었다. <br>
예제 코드에서 더 나아가 결합도를 낮추기 위한 좋은 방법으로 팩토리 패턴을 알려주셨는데 <br> 
생각해보니 새로운 TV 브랜드를 추가할 때 <br>
구현 클래스를 확장하는 것 외에도 **팩토리 클래스까지 함께 수정해야 한다**는 점이 마음에 걸렸다. <br>
이는 '확장에는 열려 있고, 수정에는 닫혀 있어야 한다'는 OCP(개방-폐쇄 원칙)를 위반하는 것이 아닌가 하는 생각이 들었다. <br>

<br>

이러한 궁금증은 강의 마지막에 강사님 설명을 들으면서 어느정도 해소되었다. <br>
SOLID 원칙을 모든 상황에서 절대적으로 지키기보다는 프로젝트의 상황과 요구사항에 맞게 <br>
유연하게 적용하는 것이 바람직하다는 것

---
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)

오늘 회고 시간에 평가 문제 풀이를 발표하는 시간을 가졌다. <br>
원래대로라면 풀고나서 틀린 문제의 답만 확인하고 넘어갔었는데 <br>
팀원들의 풀이 해설을 들으며 몰랐던 내용이나 새로운 접근법을 배울 수 있어 매우 유익했다. <br>
다른 사람의 풀이 과정을 듣는 것이 혼자 복습하는 것보다 훨씬 더 도움이 된다는 것을 깨달았다.