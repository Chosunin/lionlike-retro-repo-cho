## 0250902 회고록


### 오늘 배운 내용 중 가장 기억에 남는 3가지

1. java8 이후 java.time 패키지

* LocalDate : 날짜만 (연, 월, 일만 표현)
* LocalTime : 시간만 (시, 분, 초, 나노초만 표현)
* LocalDateTime : 날짜 + 시간 (연/월/일 + 시/분/초까지 다 포함)

```java
LocalDate date = LocalDate.of(2025, 9, 2);

// 날짜 연산
System.out.println("어제: " + date.minusDays(1));       // 어제: 2025-09-01
System.out.println("내일: " + date.plusDays(1));        // 내일: 2025-09-03
System.out.println("지난주: " + date.minusWeeks(1));    // 지난주: 2025-08-26
System.out.println("다음주: " + date.plusWeeks(1));     // 다음주: 2025-09-09
System.out.println("지난달: " + date.minusMonths(1));   // 지난달: 2025-08-02
System.out.println("다음달: " + date.plusMonths(1));    // 다음달: 2025-10-02

// 날짜 비교
LocalDate date1 = LocalDate.of(2025, 1, 1);
LocalDate date2 = LocalDate.of(2025, 9, 2);

// 2025-01-01 | 2025-09-02
Period period = Period.between(date1, date2); 
System.out.printf("두 날짜 차이: %d년 %d개월 %d일%n",
        period.getYears(),
        period.getMonths(),
        period.getDays()
);
// 두 날짜 차이: 0년 8개월 1일
```

날짜를 가지고 여러 기능들이 있으니 생각보다 할 수 있는게 많을 것 같아서 인상 깊었다.

---

### 오늘 배운 내용 중 가장 어렵거나 헷갈렸던 것 3가지

1. Comparable 과 Comparator


* `Comparable` 인터페이스
    - implements Comparable<클래스명> 
    - 객체의 기본 정렬 기준을 정의 - compareTo() 메소드 구현
    - 자바 객체가 자연스러운 순서로 정렬될 수 있도록 함 
    - 구현시 `compareTo` 메서드를 오버라이드하여 객체 간의 정렬 순서를 정의


* `Comparator` 인터페이스
    - 객체들을 특정한 기준으로 정렬할 때 사용
    - 별도의 정렬 기준을 정의 - compare() 메소드 구현
    - `compare` 메서드를 오버라이드하여 두 객체를 비교하는 방식을 정의
    - `Comparable`은 내부에서 가능한 반면 `Comparator`는 **객체 외부**에서 정렬 기준을 정의
    - getter 필요함

```java
// Comparable 방식
class TestPerson implements Comparable<TestPerson> {
    private String name;
    private int age;
    // pre code ...
    @Override
    public int compareTo(TestPerson o) {
        return this.age - o.age; // 나이 기준 오름차순
        // return this.name.compareTo(o.name); // 이름 기준
    }
    // next code ...
}
```
```java
List<TestPerson> list2 = new ArrayList<>();
list2.add(new TestPerson("홍길동", 50));
list2.add(new TestPerson("김철수", 30));

// Comparator 방식
Collections.sort(list2, new Comparator<TestPerson>() {
    @Override
    public int compare(TestPerson o1, TestPerson o2) {
        // return o1.getAge - o2.getAge; // 나이 기준
        return o1.getName().compareTo(o2.getName()); // 이름 기준
    }
});

// 람다 방식
Collections.sort(list2, (a, b) -> a.getAge().compareTo(b.getAge()));
```

처음 접해본 인터페이스라서 낯설었고, 왜 사용하는 방식이 서로 다른지 처음에 이해가 잘 안됐었다. <br>
결국 이해한 건 컴페러블은 자기자신과 비교하여 정렬하는 것이고, 컴페러터는 외부에서 기준 잡고 정렬 가능한 것으로 이해하고 넘어갔다.

---
   
### 오늘 강의시간, 회고시간에 대한 느낀점 (부족했던 부분이나 재밌었던 부분 등)

오늘은 진도를 따라가는데 크게 벅차지 않아서 다행이었다. <br>
또, 중간중간 생각할 시간이나 코드를 살펴볼 시간을 주셔서 이해하는 데 도움이 되었다.